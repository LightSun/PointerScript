import printf, strcmp;

struct Foo
{
	bar;
	tar;

	//constructor is an alias to operator new
	//destructor is an alias to operator delete
	constructor(a, b = 0)
	{
		this.bar = a + b;
	}
	/* OR
	operator new (a, b = 0)
	{
		this.bar = a + b;
	}*/

	operator + (val)
	{
		return this.bar + this.tar + val;
	}

	//supported operators for overloading are:
	//all binary and unary operators (except & and *)
	//note that ++ and -- get a boolean argument set to true when used suffixed
	operator ++ (isSuffixed)
	{
		//...
	}

	//yo ucan overload . and []
	//note that . and [] will always prefer 'real' struct member
	operator . (name)
	{
		if(strcmp(name, "xyz") != 0)
			return this.xyz; //will call this recusively
		else
			return this.bar; //will not call this recursively
	}

	//other things that are overloadable: (), cast

	dump()
	{
		printf("%-20p%-20ld%-20ld\n", this, this.bar, this.tar);
	}
};

var bla = new Foo(42);
bla.tar = 666;
bla.dump();

printf("bla + 1337 = %ld\n", bla + 1337);

delete bla;
